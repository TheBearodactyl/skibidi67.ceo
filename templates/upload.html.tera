{% extends "base" %}

{% block title %}Upload — {{ site_host }}{% endblock %}

{% block content %}
<h2>Upload</h2>

{% if not user %}
  <p>You must be <a href="/auth/login">signed in</a> to upload.</p>
{% else %}
  <form id="upload-form">
    <p>
      <label for="title">Title</label><br>
      <input id="title" type="text" required maxlength="200">
    </p>
    <p>
      <label for="file">File (max 100 MB)</label><br>
      <input id="file" type="file" required>
    </p>
    <p>
      <label>
        <input id="nsfw" type="checkbox">
        Mark as NSFW
      </label>
    </p>
    <p>
      <label>
        <input id="unlisted" type="checkbox">
        Unlisted (hidden from public listing)
      </label>
    </p>
    <p>
      <label>
        <input id="comments-disabled" type="checkbox" checked>
        Disable comments
      </label>
    </p>
    <p>
      <button type="submit">Upload</button>
    </p>
    <p id="progress" hidden>Uploading…</p>
  </form>

  <pre id="result" hidden></pre>
{% endif %}
{% endblock %}

{% block scripts %}
{% if user %}
<script>
const CHUNK_SIZE = 5 * 1024 * 1024;

const KNOWN_MEDIA_PREFIXES = ['video/', 'audio/', 'image/'];

function is_known_media_type(file_type) {
  return KNOWN_MEDIA_PREFIXES.some(function(p) { return file_type.startsWith(p); });
}

function get_api_prefix(file_type) {
  if (file_type.startsWith('audio/')) return '/audio';
  if (file_type.startsWith('image/')) return '/images';
  if (file_type === 'text/plain') return '/text';
  return '/videos';
}

function get_ui_prefix(file_type) {
  if (file_type.startsWith('audio/')) return '/ui/audio/';
  if (file_type.startsWith('image/')) return '/ui/images/';
  if (file_type === 'text/plain') return '/ui/text/';
  return '/ui/videos/';
}

function detect_text_file(file) {
  return new Promise(function(resolve) {
    var reader = new FileReader();
    reader.onload = function() { resolve(true); };
    reader.onerror = function() { resolve(false); };
    reader.readAsText(file);
  });
}

document.getElementById('upload-form').addEventListener('submit', async function(e) {
  e.preventDefault();
  const title  = document.getElementById('title').value.trim();
  const file   = document.getElementById('file').files[0];
  const nsfw   = document.getElementById('nsfw').checked;
  const unlisted = document.getElementById('unlisted').checked;
  const comments_disabled = document.getElementById('comments-disabled').checked;
  const prog   = document.getElementById('progress');
  const result = document.getElementById('result');
  const btn    = this.querySelector('button[type="submit"]');

  if (!file) { alert('Please choose a file.'); return; }

  var effective_type = file.type;

  if (!is_known_media_type(effective_type)) {
    prog.hidden = false;
    prog.textContent = 'Checking file content…';
    var is_text = await detect_text_file(file);
    if (is_text) {
      effective_type = 'text/plain';
    } else {
      alert('Unsupported file type. The file must be a video, audio, image, or valid text (UTF-8) file.');
      return;
    }
  }

  prog.hidden = false;
  prog.textContent = 'Uploading… 0%';
  btn.disabled = true;

  try {
    if (file.size > CHUNK_SIZE) {
      await chunked_upload(file, effective_type, title, nsfw, unlisted, comments_disabled, prog, result);
    } else {
      await single_upload(file, effective_type, title, nsfw, unlisted, comments_disabled, prog, result);
    }
  } catch (err) {
    prog.textContent = 'Upload failed: ' + err.message;
  } finally {
    btn.disabled = false;
  }
});

function single_upload(file, effective_type, title, nsfw, unlisted, comments_disabled, prog, result) {
  const api = get_api_prefix(effective_type);
  const ui_prefix = get_ui_prefix(effective_type);
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    var upload_url = api + '/upload?title=' + encodeURIComponent(title) + '&nsfw=' + nsfw + '&unlisted=' + unlisted + '&comments_disabled=' + comments_disabled;
    if (effective_type === 'text/plain' && file.name) {
      upload_url += '&filename=' + encodeURIComponent(file.name);
    }
    xhr.open('POST', upload_url);
    xhr.setRequestHeader('Content-Type', effective_type);

    xhr.upload.onprogress = (e) => {
      if (e.lengthComputable) {
        var pct = Math.round(e.loaded / e.total * 100);
        prog.textContent = 'Uploading… ' + pct + '%';
        if (pct >= 100 && effective_type.startsWith('video/') && effective_type !== 'video/mp4') {
          prog.textContent = 'Processing…';
        }
      }
    };

    xhr.onload = () => {
      const data = JSON.parse(xhr.responseText);
      result.hidden = false;
      result.textContent = JSON.stringify(data, null, 2);
      if (xhr.status === 201) {
        prog.textContent = data.deduplicated ? 'Done! (file deduplicated)' : 'Done!';
        setTimeout(() => window.location.href = ui_prefix + data.video.id, 600);
      } else {
        prog.textContent = 'Upload failed.';
      }
      resolve();
    };

    xhr.onerror = () => { prog.textContent = 'Network error.'; reject(new Error('Network error')); };
    xhr.send(file);
  });
}

async function chunked_upload(file, effective_type, title, nsfw, unlisted, comments_disabled, prog, result) {
  const api = get_api_prefix(effective_type);
  const ui_prefix = get_ui_prefix(effective_type);
  const total_chunks = Math.ceil(file.size / CHUNK_SIZE);

  const init_res = await fetch(api + '/upload/init?content_type=' + encodeURIComponent(effective_type), {
    method: 'POST'
  });
  if (!init_res.ok) {
    const err = await init_res.json();
    throw new Error(err.message || err.error || 'Init failed');
  }
  const { upload_id } = await init_res.json();

  for (let i = 0; i < total_chunks; i++) {
    const start = i * CHUNK_SIZE;
    const end = Math.min(start + CHUNK_SIZE, file.size);
    const chunk = file.slice(start, end);

    await new Promise((resolve, reject) => {
      const xhr = new XMLHttpRequest();
      xhr.open('PUT', api + '/upload/' + upload_id + '/' + i);
      xhr.setRequestHeader('Content-Type', 'application/octet-stream');

      xhr.upload.onprogress = (e) => {
        if (e.lengthComputable) {
          const chunk_progress = e.loaded / e.total;
          const overall = ((i + chunk_progress) / total_chunks) * 100;
          prog.textContent = 'Uploading… ' + Math.round(overall) + '%';
        }
      };

      xhr.onload = () => {
        if (xhr.status >= 200 && xhr.status < 300) {
          resolve();
        } else {
          let msg = 'Chunk upload failed';
          try { msg = JSON.parse(xhr.responseText).message || msg; } catch {}
          reject(new Error(msg));
        }
      };

      xhr.onerror = () => reject(new Error('Network error on chunk ' + i));
      xhr.send(chunk);
    });
  }

  prog.textContent = 'Processing… 0%';
  var complete_url = api + '/upload/' + upload_id + '/complete?title=' + encodeURIComponent(title) + '&nsfw=' + nsfw + '&unlisted=' + unlisted + '&comments_disabled=' + comments_disabled;
  if (effective_type === 'text/plain' && file.name) {
    complete_url += '&filename=' + encodeURIComponent(file.name);
  }

  var progress_interval = null;
  if (effective_type.startsWith('video/')) {
    progress_interval = setInterval(async function() {
      try {
        var r = await fetch('/videos/upload/' + upload_id + '/progress');
        var d = await r.json();
        if (d.progress !== null) {
          prog.textContent = 'Processing… ' + d.progress + '%';
        }
      } catch (_) {}
    }, 500);
  }

  const complete_res = await fetch(complete_url, { method: 'POST' });
  if (progress_interval) clearInterval(progress_interval);
  const data = await complete_res.json();
  result.hidden = false;
  result.textContent = JSON.stringify(data, null, 2);

  if (complete_res.status === 201) {
    prog.textContent = data.deduplicated ? 'Done! (file deduplicated)' : 'Done!';
    setTimeout(() => window.location.href = ui_prefix + data.video.id, 600);
  } else {
    throw new Error(data.message || data.error || 'Processing failed');
  }
}
</script>
{% endif %}
{% endblock %}
